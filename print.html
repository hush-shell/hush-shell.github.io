<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Hush</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="foreword.html"><strong aria-hidden="true">1.</strong> Foreword</a></li><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">2.</strong> Overview</a></li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">3.</strong> Installation</a></li><li class="chapter-item expanded "><a href="intro/index.html"><strong aria-hidden="true">4.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="intro/type-system.html"><strong aria-hidden="true">4.1.</strong> Type System</a></li><li class="chapter-item expanded "><a href="intro/basic-constructs.html"><strong aria-hidden="true">4.2.</strong> Basic Constructs</a></li><li class="chapter-item expanded "><a href="intro/control-flow.html"><strong aria-hidden="true">4.3.</strong> Control Flow and Functions</a></li></ol></li><li class="chapter-item expanded "><a href="error-handling.html"><strong aria-hidden="true">5.</strong> Error Handling</a></li><li class="chapter-item expanded "><a href="cmd/index.html"><strong aria-hidden="true">6.</strong> Shell capabilities</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cmd/basic.html"><strong aria-hidden="true">6.1.</strong> Command blocks</a></li><li class="chapter-item expanded "><a href="cmd/capture.html"><strong aria-hidden="true">6.2.</strong> Capture</a></li><li class="chapter-item expanded "><a href="cmd/async.html"><strong aria-hidden="true">6.3.</strong> Async</a></li><li class="chapter-item expanded "><a href="cmd/builtins.html"><strong aria-hidden="true">6.4.</strong> Builtins</a></li></ol></li><li class="chapter-item expanded "><a href="std.html"><strong aria-hidden="true">7.</strong> Standard Library</a></li><li class="chapter-item expanded "><a href="paradigms/index.html"><strong aria-hidden="true">8.</strong> Paradigms</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="paradigms/oop.html"><strong aria-hidden="true">8.1.</strong> Object Oriented</a></li><li class="chapter-item expanded "><a href="paradigms/fun.html"><strong aria-hidden="true">8.2.</strong> Functional</a></li></ol></li><li class="chapter-item expanded "><a href="wrapping-up.html"><strong aria-hidden="true">9.</strong> Wrapping up</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Hush</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/hush-shell/hush" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="foreword"><a class="header" href="#foreword">Foreword</a></h1>
<p>This is the official guide of <a href="https://github.com/hush-shell/hush"><em>Hush</em></a>, a modern shell scripting language. A shell scripting language is a domain specific language which provides constructs for easily invoking and interconnecting external programs. These kind of languages are typically used for integrations in Unix systems and infrastructure programming. <a href="https://www.gnu.org/software/bash/">GNU Bash</a>, <a href="https://www.zsh.org/">Zsh</a> and <a href="https://fishshell.com/">Fish</a> are some of the most commonly used ones.</p>
<p align="center">
	<img width="100px" src="images/logo.png" alt="Logo" />
	<br>
	<small>Hush's logo</small>
</p>
<h2 id="but-why-do-we-need-a-new-shell-scripting-language"><a class="header" href="#but-why-do-we-need-a-new-shell-scripting-language">But why do we need a new shell scripting language?</a></h2>
<p>Traditional shell scripting languages are notoriously limited, error prone, and frequently result in programs that are hard to maintain. Even Google mentions it on their <a href="https://google.github.io/styleguide/shellguide.html#when-to-use-shell">Shell Style Guide</a>:</p>
<blockquote>
<p>If you are writing a script that is more than 100 lines long, or that uses non-straightforward control flow logic, you should rewrite it in a more structured language now. Bear in mind that scripts grow. Rewrite your script early to avoid a more time-consuming rewrite at a later date.</p>
</blockquote>
<p>Hush strives to enable the development of robust and maintainable shell scripts. It does so by providing industry proved programming constructs, support for beyond trivial data structures, sane error handling and variable expansion. While most shells are command interpreters that strive to become programming languages, Hush is more like a general purpose programming language with first class shell capabilities.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>In order to attain it's goals, <em>Hush</em> takes great inspiration in <em>Lua</em>, the industry proven embedded scripting language. If you're familiar with <em>Lua</em>, you'll notice that, except for the shell capabilities, <em>Hush</em> feels a lot like a simplified version of it.</p>
<p>As such, <em>Hush</em> provides:</p>
<ul>
<li>Static scoping</li>
<li>Strong dynamic typing</li>
<li>Garbage collection</li>
<li>First class functions</li>
<li>Good support for functional programming</li>
<li>Basic support for object oriented programming</li>
<li>First class shell capabilities</li>
</ul>
<p>While being somewhat similar to scripting languages like <em>Lua</em>, <em>Python</em> and <em>Ruby</em>, even though it is much simpler than those, <em>Hush</em> strives to feel pretty much like <em>Bash</em> when it comes to shell capabilities. There are only minor syntax differences regarding invoking and interconnecting external programs, and therefore you won't have to learn all the shell syntax again.</p>
<p>But while most shell and even generic purpose script languages focus a lot on <strong>flexibility</strong>, <em>Hush</em> favors <strong>robustness</strong>, which may come at cost of some flexibility. As such, the language will make it's best to empower the programmer to write robust scripts that work diverse scenarios. It does so by preventing, by design, whole classes of bugs that often occur in shell scripts.</p>
<p>Being a shell script language, the typical use cases for <em>Hush</em> are operating systems instrumenting and infrastructure programming. In practice, <em>Hush</em> should be a good fit in any scenario where the heavy lifting is done by external programs, and you just need to put them to work together.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p><em>Hush</em> comes as a single binary, which can be installed on Unix systems without much hassle.</p>
<h2 id="packaged-distributions"><a class="header" href="#packaged-distributions">Packaged distributions</a></h2>
<p>Currently, <em>Hush</em> is packaged for the following operating systems:</p>
<ul>
<li>Arch Linux: <a href="https://aur.archlinux.org/packages/hush-bin">AUR</a></li>
</ul>
<h2 id="binary-download"><a class="header" href="#binary-download">Binary download</a></h2>
<p>Precompiled binaries may be downloaded from the <a href="https://github.com/hush-shell/hush/releases">Github releases</a> page. Currently, there is only a x86 Linux binary. If you would like to help by providing binaries for other architectures or operating systems, please let me know.</p>
<h2 id="building-from-source"><a class="header" href="#building-from-source">Building from source</a></h2>
<p><em>Hush</em> can be installed from source using <a href="https://crates.io/crates/hush">cargo</a>:</p>
<pre><code class="language-bash">cargo install hush
</code></pre>
<h2 id="editor-support"><a class="header" href="#editor-support">Editor support</a></h2>
<p>The following editors have plugins available:</p>
<ul>
<li>Emacs: <a href="https://github.com/hush-shell/hush/blob/master/syntax-highlight/emacs/hush-mode.el">hush-mode.el</a>. I'll release it on Melpa as soon as I find the time.</li>
<li>VsCode: <a href="https://marketplace.visualstudio.com/items?itemName=hush-vscode.hush">marketplace</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>In this section, we'll learn more about the basic constructs provided by <em>Hush</em>. That'll enable you to implement <em>Hush</em> scripts using functions, data structures, and control flow.</p>
<h2 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h2>
<p>With <em>Hush</em> installed, we're able to execute scripts. Here's the traditional <em>Hello world</em> program in <em>Hush</em>:</p>
<pre><code class="language-hush">#!/usr/bin/env hush

std.print(&quot;Hello world!&quot;)
</code></pre>
<p>The first line is a <a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">Shebang</a>. It tells the operating system which interpreter to use for the script. The second line is a function call of the <code>print</code> function from the standard library. When executed, this script will output <code>Hello world!</code> to the standard output.</p>
<h2 id="making-the-script-executable"><a class="header" href="#making-the-script-executable">Making the script executable</a></h2>
<p>To execute this script, save it to a file named <code>hello-world.hsh</code>, give it execution permission, and then run it:</p>
<pre><code class="language-shell">$ chmod +x hello-world.hsh
$ ./hello-world.hsh
Hello world!
</code></pre>
<h2 id="calling-hush-directly"><a class="header" href="#calling-hush-directly">Calling Hush directly</a></h2>
<p>You can also execute a given script calling <em>Hush</em> with the script path as argument. When executing a script using this method, the <em>Shebang</em> is unnecessary, and will be disregarded as an ordinary comment.</p>
<pre><code class="language-shell">$ hush hello-world.hsh
Hello world!
</code></pre>
<h2 id="tooling"><a class="header" href="#tooling">Tooling</a></h2>
<p><em>Hush</em> provides some tools for static analyses of scripts, which can be invoked by passing flags to the shell. The most useful one is the <code>--check</code> flag, which will check the script for syntax and semantic errors, without executing it.</p>
<p>Consider the following <code>script.hsh</code>, which attempts to use the undeclared variable <code>value</code>:</p>
<pre><code class="language-hush">value = &quot;Hello world!&quot;
std.print(value)
</code></pre>
<p>We can check verify that the script has semantic errors:</p>
<pre><code class="language-shell">$ hush --check script.hsh
Error: script.hsh (line 1, column 0) - undeclared variable 'value'
Error: script.hsh (line 2, column 10) - undeclared variable 'value'
</code></pre>
<p>To get a list of other useful flags, run <code>hush --help</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-system"><a class="header" href="#type-system">Type System</a></h1>
<p><em>Hush</em> is strongly dynamically typed, which means all <strong>values</strong> have a <strong>well formed type</strong>, but <strong>variables</strong> are <strong>untyped</strong>. Therefore, you may assign values of distinct types to a given variable. <em>Python</em>, <em>Ruby</em>, and <em>Lua</em> are also dynamically typed languages, in case you're familiar with any of them.</p>
<p>As in <em>Lua</em>, <em>Hush</em> proposes only a handful of built-in types, and no user-defined types. This makes the type system extremely simple, and yet still it remains quite expressive. The following types are available:</p>
<ul>
<li><code>nil</code>: the unit type, usually for representing missing values.</li>
<li><code>bool</code>: the boolean type.</li>
<li><code>int</code>: a 64 bit integer type.</li>
<li><code>float</code>: a 64 bit floating point type.</li>
<li><code>char</code>: a C-like unsigned char type, 0-255.</li>
<li><code>string</code>: a char-array like immutable string.</li>
<li><code>array</code>: a heterogeneous array, 0-indexed (unlike in <em>Lua</em>).</li>
<li><code>dict</code>: a heterogeneous hash map.</li>
<li><code>function</code>: a callable function.</li>
<li><code>error</code>: a special error type, to ease distinction of errors from other values. This type can only be instantiated by the built-in <code>std.error</code> function.</li>
</ul>
<p>Although it may seem like a limitation to only have a handful of types, <em>Hush</em> provides facilities that enable these types to be extremely flexible. We'll get more in depth about that in practice on the <a href="intro/../paradigms/index.html">Paradigms</a> section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-constructs"><a class="header" href="#basic-constructs">Basic Constructs</a></h1>
<p>As <em>Hush</em> aims to be simple language, only standard control flow constructs and operations are supported.</p>
<h2 id="comments"><a class="header" href="#comments">Comments</a></h2>
<p>Comments start with a <code>#</code>:</p>
<pre><code class="language-hush"># This is a comment.
</code></pre>
<h2 id="variables"><a class="header" href="#variables">Variables</a></h2>
<p>In <em>Hush</em>, all variables must be declared. This slightly increases verbosity, but makes scope rules way more reasonable, and will prevent you from ever debugging why the value of the <code>collcetion</code> variable is <code>nil</code> (note the typo).</p>
<pre><code class="language-hush">let x # Introduces the variable in the local scope

let pi = 3.14 # Syntax sugar for assignment

let string = &quot;hello!&quot;

let byte = 'a', # this is a single byte, not a string. Note the single quotes.

let array = [ 1, 2, 3, 4 ]

let dictionary = @[
	key: pi,
	items: array,
	nested: @[ one: 1, two: 2 ],
]
</code></pre>
<p>Identifiers must start with a letter or underscore, and may contain further letters, digits and underscores.</p>
<h2 id="operators"><a class="header" href="#operators">Operators</a></h2>
<p><em>Hush</em> provides standard arithmetic, logical, relational and indexing operators.</p>
<ul>
<li><strong>Arithmetic</strong> <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>: <em>int</em> <strong>or</strong> <em>float</em>; <code>%</code>: <em>int</em> only. These operators <strong>do not</strong> promote <em>ints</em> to <em>float</em>, and will <em>panic</em> with mismatching types. You may explicitly convert your <em>ints</em> to <em>float</em> prior to applying the operators.</li>
<li><strong>Logical</strong> <code>and</code>, <code>or</code>, <code>not</code>: <em>bool</em> only. Logical operators are <a href="https://en.wikipedia.org/wiki/Short-circuit_evaluation">short-circuiting</a>.</li>
<li><strong>Relational</strong> <code>==</code>, <code>!=</code>: all types; <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>: <em>int</em>, <em>float</em>, <em>byte</em>, <em>string</em> only.</li>
<li><strong>String concatenation</strong> <code>++</code>: <em>string</em> only.</li>
<li><strong>Indexing</strong> <code>[]</code>, <code>.</code>: <em>array</em>, <em>dict</em>, <em>string</em>, <em>error</em> only. Attempts to access an index out of bounds will result in a <em>panic</em>. Additionally, <em>dicts</em> and <em>errors</em> may be indexed with the dot <code>.</code> operator, as long as the key is a valid identifier.</li>
</ul>
<pre><code class="language-hush">let array = [
	1 + 2,
	3.0 * std.float(4), # explicit conversion to float.
	21 % std.int(5.2), # explicit conversion to int.
	false and not true, # will short circuit.
	1 == 1.0, # false, int and float are always distinct.
	&quot;abc&quot; &gt; &quot;def&quot;,
	&quot;hello&quot; ++ &quot; world&quot;,
]

std.assert(array[0] == 3)

# this would cause a panic:
# let x = array[5]

let dictionary = @[
	age: 20,
	height: 150,
	greet: function()
		std.print(&quot;hello!&quot;)
	end,
]

std.assert(dictionary[&quot;age&quot;] == 20)
std.assert(dictionary.height == 150)
dictionary.greet() # prints &quot;hello!&quot;
</code></pre>
<p>As you may be wondering, the standard library, which can be used through the <code>std</code> global variable, is nothing but a dictionary full of useful functions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-flow-and-functions"><a class="header" href="#control-flow-and-functions">Control Flow and Functions</a></h1>
<h2 id="if-expressions"><a class="header" href="#if-expressions"><em>If</em> expressions</a></h2>
<p>In <em>Hush</em>, conditionals expect a condition of type <em><strong>bool</strong></em>. Attempt to  use values of other types, such as <em>nil</em>, will result in a panic.</p>
<p><em>If</em> expressions may assume two forms, with and without the <code>else</code> fragment:</p>
<pre><code class="language-hush">let condition = true

if condition then
	# ...
end

if condition then
	# ...
else
	# ...
end
</code></pre>
<p>As they are expressions, they will evaluate to whatever is the value resulting in the last statement of the executed block. If the <code>else</code> block is omitted and the condition evaluates to <code>false</code>, the expression will result in <code>nil</code>.</p>
<pre><code class="language-hush">let condition = false

let x = if condition then
	1
else
	2
end

std.assert(x == 2)

x = if condition then
	3
end

std.assert(x == nil)
</code></pre>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<p>Functions are first class citizens, which means they are values like any other. The following are equivalent:</p>
<pre><code class="language-hush">let fun = function ()
	# ...
end

function fun()
	# ...
end
</code></pre>
<p>They must declare how many arguments they expect, which is enforced when calling a function. Calling a function with less or more arguments than expected will result in a panic.</p>
<pre><code class="language-hush">function takes_one(x)
	# ...
end

function takes_two(x, y)
	# ...
end

takes_one(1)
takes_two(&quot;a&quot;, 2)
</code></pre>
<p>Contrary to <em>Lua</em>, functions in <em>Hush</em> always return a single value, which is the result of the last statement in their body. They also may return early with the <code>return</code> keyword. The following are equivalent:</p>
<pre><code class="language-hush">function fun(x)
	if x &gt;= 2 then
		return # implicitly returns `nil`
	else
		return &quot;lower than 2&quot;
	end
end

function fun(x)
	if x &lt; 2 then
		&quot;lower than 2&quot;
	end
end
</code></pre>
<p><em>Hush</em> implements <a href="https://en.wikipedia.org/wiki/Scope_(computer_science)#Lexical_scope_vs._dynamic_scope_2">lexical scoping</a>, which means variables are enclosed in the body in which they are declared, just like in <em>Python</em> and <em>Lua</em>. It also supports closures, which are functions that capture variables from the enclosing scope:</p>
<pre><code class="language-hush">function adder(x)
	let y = x + 1

	return function (z) # `return` may be ommited here
		y + z # captures `y` from the parent scope.
	end
end

std.assert(adder(1)(2) == 4)
</code></pre>
<p>Closures may even mutate the captured variables:</p>
<pre><code class="language-hush">let x = 0

function increment()
	x = x + 1
end

increment()
increment()
increment()

std.assert(x == 3)
</code></pre>
<p>Functions can also be recursive. As they are values, recursive functions are actually closures on themselves (they capture the variable to which they are assigned).</p>
<pre><code class="language-hush">function factorial(n)
	if n == 0 then
		1
	else
		n * factorial(n - 1)
	end
end

std.assert(factorial(5) == 120)
</code></pre>
<h3 id="self"><a class="header" href="#self">Self</a></h3>
<p><em>Hush</em> provides one further facility for functions: the <code>self</code> keyword. When calling a function inside a dictionary using the dot operator, <code>self</code> will be an alias to that dictionary. If the function is called through other means, <code>self</code> will be <code>nil</code>. This is frequently used in <a href="intro/../paradigms/oop.html">object oriented</a> code.</p>
<pre><code class="language-hush">let dict = @[
	value: 5,

	method: function()
		# `self` is a reference to the dictionary which contains the function, if any.
		std.print(self)
	end
]

dict.method() # @[ &quot;value&quot;: 5, &quot;method&quot;: function&lt;...&gt; ]

# Isolate the method from the object, which will cause `self` to be `nil`:
let method = dict.method
method() # nil

# But we can bind it back to the object using `std.bind(obj, method)`:
method = std.bind(dict, dict.method)
method() # @[ &quot;value&quot;: 5, &quot;method&quot;: function&lt;...&gt; ]
</code></pre>
<h2 id="while-loops"><a class="header" href="#while-loops"><em>While</em> loops</a></h2>
<p><em>While</em> loops are statements, and therefore cannot be used as expressions.</p>
<pre><code class="language-hush">let condition = true
let i = 0

while condition do
	condition = false
	i = i + 1
end

std.assert(i == 1)
</code></pre>
<h2 id="for-loops"><a class="header" href="#for-loops"><em>For</em> loops</a></h2>
<p><em>For</em> loops are also statements, but opposed to <em>While</em> loops, they do not expect a boolean condition. First, they expect a variable name, which will be scoped to the loop's body. Second, they expect an iterator function.</p>
<p>An iterator function is a function that may be called repeatedly without arguments, and always returns a dictionary with at least one field:</p>
<ul>
<li><code>finished</code>: a boolean indicating whether the loop should stop.</li>
<li><code>value</code>: the value to be assigned to the loop variable. May be omitted if <code>finished</code> is <code>false</code>.</li>
</ul>
<pre><code class="language-hush"># A function to generate an iterator to the given array.
function iter(array)
	let i = -1
	let len = std.len(array)

	function ()
		i = i + 1 # captures `i`, incrementing it on every call.

		if i == len then # check if we reached the captured `len`.
			@[ finished: true ]
		else
			@[ finished: false, value: array[i] ]
		end
	end
end

let array = [1, 2, 3]
let sum = 0

for item in iter(array) do
	sum = sum + item
end

std.assert(sum == 6)
</code></pre>
<p>Fortunately, the <code>iter</code> function defined above is present in the standard library, as <code>std.iter(collection)</code>. For numeric iterations, the standard library also supplies the <code>std.range(from, to, step)</code> function, which returns an iterator:</p>
<pre><code class="language-hush">let sum = 0

for i in std.range(1, 4, 1) do
	sum = sum + i
end

std.assert(sum == 6)
</code></pre>
<h2 id="break-statement"><a class="header" href="#break-statement"><em>Break</em> statement</a></h2>
<p>One may also interrupt loops using the <code>break</code> statement:</p>
<pre><code class="language-hush">while true do # this will not run forever.
	if 1 + 2 &lt; 4 then
		break
	end
end
</code></pre>
<h2 id="wrapping-up"><a class="header" href="#wrapping-up">Wrapping up</a></h2>
<p>With these constructs, you should be able to write basic programs in <em>Hush</em>. Next, we'll learn how to implement proper error handling, as robustness is one of the core values of the language.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h1>
<p><em>Hush</em> implements two error mechanisms: <em>panics</em> and <em>errors</em>.</p>
<h2 id="panic"><a class="header" href="#panic">Panic</a></h2>
<p>A <em>Panic</em> is an <strong>irrecoverable</strong><sup class="footnote-reference"><a href="#panic">1</a></sup> error, and will occur when there is a logic issue in your code. <em>Panics</em> will cause the whole program to crash, and execution will be terminated.</p>
<pre><code class="language-hush">let x = 1 / 0
std.print(x)
</code></pre>
<p>Running the above script, you'll get:</p>
<pre><code>Panic in &lt;stdin&gt; (line 2, column 10): division by zero
</code></pre>
<p>Examples of errors that cause a panic:</p>
<ul>
<li>Syntax error.</li>
<li>Integer division by zero.</li>
<li>Index out of bounds.</li>
<li>Attempt to call a value that is not a function.</li>
<li>Missing or exceeding arguments in function call.</li>
</ul>
<h2 id="error"><a class="header" href="#error">Error</a></h2>
<p><strong>Recoverable</strong> errors may be expressed through values of the <em>error</em> type. This is a special type in the language, and it is the only which cannot be expressed through a literal. Values of the error type can only be created using the <code>std.error</code> function, which expects a string description and a arbitrary context:</p>
<pre><code class="language-hush">function check_limit(x)
	if x &gt; 10 then
		std.error(&quot;x cannot be bigger than 10&quot;, x)
	else
		x
	end
end
</code></pre>
<p>One can then check whether the function has returned an error:</p>
<pre><code class="language-hush">let result = check_limit(11)

if std.type(result) == &quot;error&quot; then
	std.print(&quot;Error: &quot;, result)
else
	std.print(&quot;Success: &quot;, result)
end
</code></pre>
<p>The <em>description</em> and <em>context</em> fields can be accessed as in a dictionary, but unlike in dictionaries, those cannot be assigned to:</p>
<pre><code class="language-hush">let error = std.error(&quot;oh no!&quot;, 42)

std.print(error.description) # oh no!

error.description = &quot;you shouldn't do that!&quot; # panic
</code></pre>
<p>Examples of errors should be recoverable:</p>
<ul>
<li>File not found.</li>
<li>Insufficient permission</li>
<li>Invalid format</li>
<li>Command not found</li>
<li>Command returned non-zero exit status</li>
</ul>
<h2 id="try-operator"><a class="header" href="#try-operator">Try operator</a></h2>
<p>The try (<code>?</code><sup class="footnote-reference"><a href="#try">2</a></sup>) operator may be used to early return from a function if an error occurs. It is nothing but syntax sugar for an <em>if</em> expression, and therefore it may be used in any expression:</p>
<pre><code class="language-hush">function safe_div_mod(x, y)
	if y == 0 then
		std.error(&quot;division by zero&quot;, nil)
	else
		@[ div: x / y, mod: x % y ]
	end
end

# The following are equivalent:

function foo()
	let result = safe_div_mod(5, 0)
	
	let value = if std.type(result) == &quot;error&quot; then
		return result
	else
		result
	end

	std.print(value)
end

function bar()
	let value = safe_div_mod(5, 0)?
	std.print(value) # this won't be executed, as `?` will trigger an early return.
end

# The `?` operator may be used in any expression:
function run()
	std.print(&quot;div: &quot;, safe_div_mod(5, 0)?.div)
end
</code></pre>
<p><sup class="footnote-reference"><a href="#panic">1</a></sup> One can actually <em>catch</em> a <em>panic</em> using the <code>std.catch</code> function, but that should be used sparingly.</p>
<p><sup class="footnote-reference"><a href="#try">2</a></sup> If you're familiar with both languages, <em>Hush</em>'s try operator might feel like the unholy child of Rust's <code>?</code> operator and Go's <code>if err != nil { return err }</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-blocks"><a class="header" href="#command-blocks">Command Blocks</a></h1>
<p>Command blocks is the feature that distinguishes <em>Hush</em> from ordinary programming languages. They allow <em>Hush</em> scripts to seamlessly invoke and interconnect external programs.</p>
<p>Great effort has been put to make command syntax in <em>Hush</em> as similar as we're used to in <em>Bash</em>, but some key aspects have been changed in order to favor robustness of scripts. You should never have to use something like the <a href="http://redsymbol.net/articles/unofficial-bash-strict-mode/">unofficial bash strict mode</a> in <em>Hush</em>:</p>
<pre><code class="language-bash">#!/bin/bash
set -euo pipefail
IFS=$'\n\t'
</code></pre>
<p align="center">
	<small>The unofficial bash strict mode</small>
</p>
<p>Let's see why you won't need any of this in <em>Hush</em>:</p>
<ul>
<li><code>set -e</code>: interrupt execution immediately if a command has non-zero exit status. This is the default behavior for command blocks in <em>Hush</em>.</li>
<li><code>set -u</code>: exit with an error on any attempt to use an undeclared variable. <em>Hush</em> won't even start to execute your script if you mention an undeclared variable.</li>
<li><code>set -o pipefail</code>: if a command in a pipeline fails, make the whole pipeline fail. This is the default behavior in <em>Hush</em>, and can even be controlled on a per-command basis in pipelines.</li>
<li><code>IFS=$'\n\t'</code>: do word-splitting using only newlines and hard tabs. <em>Hush</em> does no word splitting whatsoever, so this will never be a source of confusion or bugs.</li>
</ul>
<p>In the next sections, we'll learn how to use command blocks in <em>Hush</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-blocks-1"><a class="header" href="#command-blocks-1">Command Blocks</a></h1>
<p>In <em>Hush</em>, command blocks are delimited with curly braces:</p>
<pre><code class="language-hush">{ echo Hello world! }
</code></pre>
<p>They are valid expressions, and will result in <em>error</em> or <em>nil</em>. Therefore, we can use this result to check whether the block was successfully executed:</p>
<pre><code class="language-hush">let result = {
	touch /etc/config # we may not have permission for that directory!
}

if std.type(result) == &quot;error&quot; then
	std.print(&quot;Error: &quot;, result)
end
</code></pre>
<p>They may even be combined with the <em>try</em> operator:</p>
<pre><code class="language-hush">function run()
	{ mkdir /etc/config/ }?
	std.print(&quot;Success!&quot;) # This won't be executed if the command block fails.
end

let result = run()
if std.type(result) == &quot;error&quot; then
	std.print(&quot;Error: &quot;, result)
end
</code></pre>
<p>As they are blocks, they may have multiple commands, which <strong>must</strong> be delimited by semicolons. This enables us to include line comments in between their arguments:</p>
<pre><code class="language-hush">{
	find . # search in the current directory.
		-type f # only files.
		-iname '*.png'; # case insensitive match on name.

	ls ../some-other-dir/images; # list files from another directory.

	cat additional-files.txt # The semicolon in the last command is optional.
}
</code></pre>
<h2 id="pipelines-and-redirections"><a class="header" href="#pipelines-and-redirections">Pipelines and redirections</a></h2>
<p>Pipelines and redirections use standard syntax:</p>
<pre><code class="language-hush">{
	echo Hello world! | sed s/world/universe/g | tr '!' '.';
	echo overwrite file using stdout &gt; file.txt;
	echo overwrite file using stderr 2&gt; file.txt;
	echo append to file using stdout &gt;&gt; file.txt;
	echo stderr too 2&gt;&gt; file.txt;
	cat &lt; file.txt; # redirect file to stdin
	cat &lt;&lt; &quot;here's an inline string&quot;; # string to stdin
	rm file.txt 2&gt;1; # redirect stderr to stdout. Opposed to Bash, we don't need an `&amp;`

	# We may compose as many of those as we need:
	cat file.txt # Read a file.
			&lt;&lt; &quot;Hello world!&quot; # Concat it with data from stdin.
			2&gt;&gt; errors.txt # Save errors to file.
		| tee output.txt # Dump data to another file.
			2&gt;&gt; errors.txt # Save errors to file.
		| curl localhost:8080 -d @- # HTTP POST data to server.
			2&gt;&gt; errors.txt; # Save errors to file.
}
</code></pre>
<p>But there's an additional requirement for redirections: they may not precede arguments:</p>
<pre><code class="language-hush">{ echo Hello 2&gt;1 } # Ok.
{ echo 2&gt;1 Hello } # Syntax error.
</code></pre>
<h2 id="variables-1"><a class="header" href="#variables-1">Variables</a></h2>
<p>As in most shells, <em>Hush</em> provides variable substitution in commands. But opposed to traditional shells, variables don't undergo word splitting. As <em>Hush</em> has first class support for arrays, there's really no need to do automatic word splitting. </p>
<p>Variables can be used inside command blocks using dollar syntax:</p>
<pre><code class="language-hush">let var = &quot;hello world&quot;
{
	echo $var; # hello world
	echo &quot;$var&quot;; # hello world
	echo ${var}s; # hello worlds
	echo &quot;${var}s&quot;; # hello worlds
	echo '$var'; # $var
}
</code></pre>
<p><em>Hush</em> uses the following rules when doing variable substitution:</p>
<ul>
<li><em>nil</em>: converted to an empty argument. Note that this is different than skipping the argument.</li>
<li><em>bool</em>, <em>char</em>, <em>int</em>, <em>float</em>, <em>string</em>: converted to string and passed as a <strong>single</strong> argument, regardless of containing spaces, asterisks, and whatnot.</li>
<li><em>array</em>: each element will be converted to a <em>single</em> argument, using the other rules. If the array is empty, no argument is produced. This way, arrays can be used to programmatically build lists of command arguments.</li>
<li><em>dict</em>, <em>function</em>, <em>error</em>: won't be converted, causing a <em>panic</em> instead.</li>
</ul>
<p>Considering the file <code>args.hsh</code>:</p>
<pre><code class="language-hush">let args = std.args() # Returns an array of command line arguments.

for arg in std.iter(args) do
	std.print(arg)
end
</code></pre>
<p>The following script</p>
<pre><code class="language-hush">let args = [ &quot;1 2&quot;, 3, nil, 4.0 ]

{ hush args.hsh $args }
</code></pre>
<p>will output:</p>
<pre><code>1 2
3

4.0
</code></pre>
<h2 id="expansions"><a class="header" href="#expansions">Expansions</a></h2>
<p>In order to provide ergonomic manipulation of the file system, most shells provide a mechanism named <em>expansions</em>. It allows the programmer to refer to multiple file names using a regex-like syntax.</p>
<p><em>Hush</em> provides automatic expansion <strong>only for literal arguments</strong>. That means you won't have to worry if your variables contains characters that may be expanded.</p>
<pre><code class="language-hush">let var = &quot;*&quot;
{
	echo *; # Will print all files/directories in the current directory.
	# The following will print just an asterisk.
	echo &quot;*&quot;;
	echo $var;
}
</code></pre>
<p><em>Hush</em> currently provides the following expansions:</p>
<ul>
<li><code>%</code>: matches zero or one character, except for the path separator.</li>
<li><code>*</code>: matches zero or more characters, except for the path separator.</li>
<li><code>**</code>: matches zero or more directories.</li>
<li><code>~/</code>: matches the <code>$HOME</code> directory, only when in the prefix of an argument.</li>
</ul>
<!-- - `[abc]`: mathes either of the characters between brackets. -->
<!-- - `{x..y}`: expands to multiple arguments, each one with a value in the range `x..y`. -->
<!-- - `{a,b,c}`: expands to multiples arguments, each one with a value from the collection `a,b,c`. -->
<p>Opposed to traditional shells, <em>Hush</em> will <em>always</em> expand relative paths prefixed with <code>./</code>:</p>
<pre><code class="language-hush">{
	touch test.txt; # Create a file
	echo *; # Will print &quot;./test.txt&quot;
}
</code></pre>
<p>You won't have to worry about flag injection from file names ever again.</p>
<h2 id="errors"><a class="header" href="#errors">Errors</a></h2>
<p>By default, whenever a command fails in a block, the whole block will be interrupted. This behavior can be disabled on a per-command basis with the <code>?</code> operator (not to be confused with the try operator outside of command blocks).</p>
<pre><code class="language-hush">{
	echo Hello world!;

	# `false` is a command that always fails. As it's suffixed with `?`,
	# it won't cause the whole block to abort.
	false ?;

	echo &quot;This will be printed&quot;;

	# If a command fails, and it makes no use of the `?` operator,
	# no further commands will be executed.
	false;

	echo &quot;This will not be printed&quot;;
}
</code></pre>
<p>Command blocks will <strong>always</strong> result in an <em>error</em> whenever one or more of their commands fail. This is true even for commands that use the <code>?</code> operator.</p>
<pre><code class="language-hush">let result = { false?; }
std.assert(std.type(result) == &quot;error&quot;)
</code></pre>
<p>An error will be produced for each command that fails. This error will contain a <em>dict</em> with two fields:</p>
<ul>
<li><code>pos</code>: a string describing the source position of the command.</li>
<li><code>status</code>: the numeric exit status of the program. Always non-zero.</li>
</ul>
<p>There are scenarios where more than one command may fail, such as when using pipelines or the <code>?</code> operator. Whenever more than one command fails, the block will result in a generic error. This generic error will contain as context an array of the errors of each command that failed.</p>
<pre><code class="language-hush">let result = { false?; false }
std.print(result.context[0])
# command returned non-zero (@[ &quot;status&quot;: 1, &quot;pos&quot;: &quot;&lt;stdin&gt; (line 1, column 15)&quot; ])
std.print(result.context[1])
# command returned non-zero (@[ &quot;status&quot;: 1, &quot;pos&quot;: &quot;&lt;stdin&gt; (line 1, column 23)&quot; ])
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="capture"><a class="header" href="#capture">Capture</a></h1>
<p>One of the most important features of a shell is to be able to manipulate the standard I/O streams of programs. There are three main ways of doing so: pipes, redirection, and capturing. The first two are commonly used when we just want to forward the output or input of a program. But if we want to preprocess the output, or use it as an argument to another program, we'll usually reach for capturing the output stream as a string in the shell, so that we can handle it ourselves.</p>
<p>In <em>Hush</em>, we can capture the output of a whole command block by prefixing it with a dollar:</p>
<pre><code class="language-hush">let result = ${ echo Hello world! }
</code></pre>
<p>Instead of resulting in <em>nil</em> or <em>error</em>, as does the standard command block, a capture block will result in either a <em>dict</em> containing the <em>stdout</em> and <em>stderr</em> string fields, or an <em>error</em> if the block fails.</p>
<pre><code class="language-hush">function get_first_word()
	let output = ${ echo Hello world! }?.stdout
	let first_word = std.split(std.trim(output), &quot; &quot;)[0]
	if std.is_empty(first_word) then
		std.error(&quot;output was empty&quot;, output)
	else
		first_word
	end
end

std.print(get_first_word()) # Hello
</code></pre>
<p>The separation of the <em>stdout</em> and <em>stderr</em> fields in the resulting <em>dict</em> enables the programmer to properly handle the standard error stream separately from the standard output stream, something that is more complicated than it should in traditional shells.</p>
<p>If the command block fails, the resulting <em>error</em> will contain the output that captured was captured before the block failed:</p>
<pre><code class="language-hush">let result = ${
	echo Hello world!;
	echo The next command wil fail 1&gt;2;
	this-command-does-not-exists;
}

std.assert(std.type(result) == &quot;error&quot;)
std.assert(result.context.stdout == &quot;Hello world!\n&quot;)
std.assert(result.context.stderr == &quot;The next command wil fail\n&quot;)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="async"><a class="header" href="#async">Async</a></h1>
<p><em>Hush</em> also provides a way to launch commands asynchronously, and then wait for their result at a later time. Traditional shells provide similar functionality through the ampersand operator.</p>
<p>To run a command block asynchronously, prefix it with an ampersand:</p>
<pre><code class="language-hush">let handle = &amp;{ echo Hello world! }

# Do some other work before calling join.
# This may be printed before or after &quot;Hello world!&quot;.
std.print(&quot;Doing some work...&quot;)

# This will wait until the block runs to completion, and will return it's result.
let result = handle.join()

std.assert(result == nil)
</code></pre>
<p>Async blocks will start executing immediately, but <em>Hush</em> won't wait for their completion until <em>join</em> is called, and will continue script execution instead. An async block will <strong>always</strong> result in a <em>dict</em> containing the <em>join</em> method, which will then return the block result (<em>nil</em> or <em>error</em>) when called.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="builtins"><a class="header" href="#builtins">Builtins</a></h1>
<p>Some commands must be implemented as shell builtins, so that they can mutate the shell state, a thing that would not be possible for an external program. A good example of such kind is the <code>cd</code> command, which must change the shell's working directory.</p>
<p><em>Hush</em> currently provides the following builtin commands:</p>
<ul>
<li><code>cd</code>: change the working directory to the given argument.</li>
</ul>
<p>As <em>Hush</em> has no such thing as subshells, builtin commands may not be used in pipes, redirections, or capture blocks.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="standard-library"><a class="header" href="#standard-library">Standard Library</a></h1>
<p><em>Hush</em>'s standard library is available through the <code>std</code> global variable, which is implicitly available to all scripts. It is nothing but a dictionary of predefined functions, which can be used like any other user defined functions.</p>
<p>Currently, the following functions are available:</p>
<h4 id="stdargs"><a class="header" href="#stdargs"><code>std.args()</code></a></h4>
<p>Gets an array of command line arguments.</p>
<h4 id="stdassertvalue"><a class="header" href="#stdassertvalue"><code>std.assert(value)</code></a></h4>
<p>Asserts that <code>value</code> is <code>true</code>, panics otherwise.</p>
<h4 id="stdbindobj-function"><a class="header" href="#stdbindobj-function"><code>std.bind(obj, function)</code></a></h4>
<p>Returns a new function that binds <code>function</code> to <code>obj</code>, so that <code>self</code> will always refer to <code>obj</code> when the function is called.</p>
<h4 id="stdcatchfunction"><a class="header" href="#stdcatchfunction"><code>std.catch(function)</code></a></h4>
<p>Runs the given <code>function</code>, and returns an error if it panics. This should be used sparingly, as panics shouldn't be used for recoverable errors.</p>
<h4 id="stdcddir"><a class="header" href="#stdcddir"><code>std.cd(dir)</code></a></h4>
<p>Change the current directory to <code>dir</code>.</p>
<h4 id="stdcontainscollection-value"><a class="header" href="#stdcontainscollection-value"><code>std.contains(collection, value)</code></a></h4>
<p>Checks if <code>collection</code> contains an item that is equal to <code>value</code>. May be used with <em>string</em>s, <em>array</em>s and <em>dict</em>s.</p>
<h4 id="stdcwd"><a class="header" href="#stdcwd"><code>std.cwd()</code></a></h4>
<p>Returns the current working directory.</p>
<h4 id="stdenvkey"><a class="header" href="#stdenvkey"><code>std.env(key)</code></a></h4>
<p>Gets the value of the environment variable <code>key</code>, or <em>nil</em> if it's not defined.</p>
<h4 id="stderrordescription-context"><a class="header" href="#stderrordescription-context"><code>std.error(description, context)</code></a></h4>
<p>Create a new <em>error</em> with the given description and context. The description must be a string.</p>
<h4 id="stdexportkey-value"><a class="header" href="#stdexportkey-value"><code>std.export(key, value)</code></a></h4>
<p>Set the environment variable <code>key</code> to <code>value</code>. Both arguments must be <em>string</em>s.</p>
<h4 id="stdfloatvalue"><a class="header" href="#stdfloatvalue"><code>std.float(value)</code></a></h4>
<p>Convert <code>value</code> to <em>float</em>. Accepts <em>string</em>, <em>int</em> and <em>float</em>.</p>
<h4 id="stdglobpath"><a class="header" href="#stdglobpath"><code>std.glob(path)</code></a></h4>
<p>Expands the given <code>path</code> in the current directory, using the shell expansion rules (<code>*</code>, <code>%</code>, etc).</p>
<h4 id="stdhas_errorvalue"><a class="header" href="#stdhas_errorvalue"><code>std.has_error(value)</code></a></h4>
<p>Recursively checks if <code>value</code> contains a value of type <em>error</em>.</p>
<h4 id="stdimportpath"><a class="header" href="#stdimportpath"><code>std.import(path)</code></a></h4>
<p>Load the <em>Hush</em> script from the given path, relative to the current file.</p>
<h4 id="stdintvalue"><a class="header" href="#stdintvalue"><code>std.int(value)</code></a></h4>
<p>Convert <code>value</code> to <em>int</em>. Accepts <em>string</em>, <em>int</em> and <em>float</em>.</p>
<h4 id="stdis_emptycollection"><a class="header" href="#stdis_emptycollection"><code>std.is_empty(collection)</code></a></h4>
<p>Checks if the given <code>collection</code> is empty. Accepts <em>string</em>s, <em>array</em>s and <em>dict</em>s.</p>
<h4 id="stditercollection"><a class="header" href="#stditercollection"><code>std.iter(collection)</code></a></h4>
<p>Returns an iterator function for the given <code>collection</code>. Accepts <em>string</em>s, <em>array</em>s and <em>dict</em>s.</p>
<h4 id="stdjsondumpvalue"><a class="header" href="#stdjsondumpvalue"><code>std.json.dump(value)</code></a></h4>
<p>Convert the given value to a JSON <em>string</em>. Panics if <code>value</code> contains a value that cannot be serialized as JSON (<em>function</em> or <em>error</em>).</p>
<h4 id="stdjsonparsestring"><a class="header" href="#stdjsonparsestring"><code>std.json.parse(string)</code></a></h4>
<p>Parse the given json <code>string</code>. Returns an <em>error</em> if parsing fails.</p>
<h4 id="stdlencollection"><a class="header" href="#stdlencollection"><code>std.len(collection)</code></a></h4>
<p>Returns the amount of elements in the given collection. Accepts <em>string</em>s, <em>array</em>s and <em>dict</em>s.</p>
<h4 id="stdpanicvalue"><a class="header" href="#stdpanicvalue"><code>std.panic(value)</code></a></h4>
<p>Panics with the given <code>value</code> as description.</p>
<h4 id="stdpoparray"><a class="header" href="#stdpoparray"><code>std.pop(array)</code></a></h4>
<p>Removes the last element from the given <code>array</code>, returning it. Panics if the array is empty.</p>
<h4 id="stdprintvalue"><a class="header" href="#stdprintvalue"><code>std.print(value)</code></a></h4>
<p>Prints the given value to <em>stdout</em>, including a newline.</p>
<h4 id="stdpusharray-value"><a class="header" href="#stdpusharray-value"><code>std.push(array, value)</code></a></h4>
<p>Adds the given <code>value</code> to the end of <code>array</code>.</p>
<h4 id="stdrangefrom-to-step"><a class="header" href="#stdrangefrom-to-step"><code>std.range(from, to, step)</code></a></h4>
<p>Returns an iterator function that yields numbers in the given range.</p>
<h4 id="stdreadprompt"><a class="header" href="#stdreadprompt"><code>std.read(prompt)</code></a></h4>
<p>Read a line from <em>stdin</em>, using the given <code>prompt</code>, which must be a <em>string</em>.</p>
<h4 id="stdreplacestring-seach-replace"><a class="header" href="#stdreplacestring-seach-replace"><code>std.replace(string, seach, replace)</code></a></h4>
<p>Replace occurrences of <code>search</code> with <code>replace</code> in <code>string</code>. All parameters must be <em>string</em>s.</p>
<h4 id="stdsleepms"><a class="header" href="#stdsleepms"><code>std.sleep(ms)</code></a></h4>
<p>Sleep for the given amount of milliseconds. Accepts positive integers only.</p>
<h4 id="stdsortarray"><a class="header" href="#stdsortarray"><code>std.sort(array)</code></a></h4>
<p>Sorts the given array.</p>
<h4 id="stdsplitstring-pattern"><a class="header" href="#stdsplitstring-pattern"><code>std.split(string, pattern)</code></a></h4>
<p>Splits the given <code>string</code> by occurrences of <code>pattern</code>, returning a non-empty array. Both arguments must be <em>string</em>s.</p>
<h4 id="stdsubstrstring-from-length"><a class="header" href="#stdsubstrstring-from-length"><code>std.substr(string, from, length)</code></a></h4>
<p>Slice the given <code>string</code>. The two last parameters must be positive integers.</p>
<h4 id="stdto_stringvalue"><a class="header" href="#stdto_stringvalue"><code>std.to_string(value)</code></a></h4>
<p>Converts the given value to <em>string</em>.</p>
<h4 id="stdtrimstring"><a class="header" href="#stdtrimstring"><code>std.trim(string)</code></a></h4>
<p>Removes whitespace from the start and end of the given <em>string</em>.</p>
<h4 id="stdtypecheckvalue-type"><a class="header" href="#stdtypecheckvalue-type"><code>std.typecheck(value, type)</code></a></h4>
<p>Checks if the given <code>value</code> has type <code>type</code>, panics otherwise. <code>type</code> must be a <em>string</em>.</p>
<h4 id="stdtry_typecheckvalue-type"><a class="header" href="#stdtry_typecheckvalue-type"><code>std.try_typecheck(value, type)</code></a></h4>
<p>Checks if the given <code>value</code> has type <code>type</code>, returns an <em>error</em> otherwise. <code>type</code> must be a <em>string</em>.</p>
<h4 id="stdtypevalue"><a class="header" href="#stdtypevalue"><code>std.type(value)</code></a></h4>
<p>Returns a <em>string</em> describing the type of <code>value</code>: <code>&quot;nil&quot;</code>, <code>&quot;bool&quot;</code>, <code>&quot;char&quot;</code>, <code>&quot;int&quot;</code>, <code>&quot;float&quot;</code>, <code>&quot;string&quot;</code>, <code>&quot;array&quot;</code>, <code>&quot;dict&quot;</code>, <code>&quot;function&quot;</code>, or <code>&quot;error&quot;</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="paradigms"><a class="header" href="#paradigms">Paradigms</a></h1>
<p>There are three main programming paradigms that can be used in <em>Hush</em>: procedural, functional, and object oriented programming. As the language has functions, statements and basic flow control, procedural programming comes pretty naturally. For functional programming, the support for first class and higher order functions are the core features that enable usage of such paradigm. As for object oriented programming, the language provides basic mechanisms for defining objects with fields and methods.</p>
<p>In the following sections, we'll explore examples on how to use functional and object oriented programming in <em>Hush</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="object-oriented"><a class="header" href="#object-oriented">Object Oriented</a></h1>
<p><em>Hush</em> provides basic support for object oriented programming. This means you can write object oriented code in <em>Hush</em>, but the language won't give you fancy features for free. Objects can be modeled through dictionaries, using keys as accessors and values as member data and methods. To ease the use of dictionaries as objects, <em>Hush</em> provides the <code>self</code> keyword, which is described in the <a href="paradigms/../intro/control-flow.html#functions">functions section</a>.</p>
<pre><code class="language-hush"># This function acts like a combination of a class and a constructor. It'll take any
# arguments relevant to the construction of a `MyCounter` object, and will return an
# instance of such object, which is nothing but a dictionary.
let MyCounter = function(start)
	@[
		# A member field. Using the same convention as Python, a field starting with an
		# underscore should be considered private.
		_start: start,

		# A method. Here, we can use the `self` keyword to access the object.
		get: function()
			self._start
		end,

		# Another method.
		increment: function()
			self._start = self._start + 1
		end,
	 ]
end

let counter = MyCounter(1) # object instantiation.

std.print(counter.get()) # 1
counter.increment()
std.print(counter.get()) # 2
</code></pre>
<h2 id="inheritance"><a class="header" href="#inheritance">Inheritance</a></h2>
<p>Single inheritance can be implemented using a similar technique:</p>
<pre><code class="language-hush"># A derived class.
let MySuperCounter = function (start, step)
	# Instantiate an object of the base class. We'll then augment this object with
	# derived functionality.
	let counter = MyCounter(start)

	counter._step = step # Add new fields to the object.

	# Override a method. Make sure not to change the number of parameters here!
	counter.increment = function ()
		self._start = self._start + self._step
	end

	# In order to override a method and call the parent implementation, you'll need to
	# bind it to the current object, and then store it to a variable:
	let super_get = std.bind(counter, counter.get)
	counter.get = function()
		let value = super_get() # call the parent method.
		std.print(value)
		value
	end

	counter
end


let super_counter = MySuperCounter(2, 3)
super_counter.get() # 2
super_counter.increment()
super_counter.get() # 5
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functional"><a class="header" href="#functional">Functional</a></h1>
<p><em>Hush</em> provides first class higher order functions, which is the fundamental building block for functional programming. As such, the paradigm integrates very well with the language, and it is recommend as the main approach for solving problems in <em>Hush</em>.</p>
<p>Here's an example of a simple iterator library, using functional programming and implementing basic laziness:</p>
<pre><code class="language-hush"># Iterator: traversal utilities.

# Construct an iterator.
# An Iterator is an object capable of successively yielding values.
# Iterators are *mutable* (they may mutate their inner state as they iterate).
# Parameters:
# * next: function() -&gt; @[ finished: bool, value: any ] # the iterator function
# Returns the Iterator instance.
function Iterator(next)
	@[
		# Provide the next method.
		next: next,

		# Get the iterator function.
		# Iterating mutates the iterator, which will successively yield the next value.
		# This should be used in for loops, as in:
		# for item in iterator.iter() do
		# 	...
		# end
		iter: function ()
			self.next
		end,

		# Get the nth element in the iterator.
		# This is equivalent to calling self.next() `n + 1` times,
		# but might be optimized for some iterators.
		# Parameters:
		# * n: the desired element index
		# Returns the nth element.
		nth: function (n)
			for _ in std.range(0, n, 1) do
				let iteration = self.next()

				if iteration.finished then
					return iteration
				end
			end

			self.next()
		end,

		# Map a function over an iterator.
		# This function is lazy.
		# Parameters:
		# * fun: function(any) -&gt; any # the function to apply
		# Returns a new iterator, consuming self.
		map: function (fun)
			let map = function (iteration)
				if iteration.finished then
					iteration
				else
					@[ finished: false, value: fun(iteration.value) ]
				end
			end

			let base = self

			let it = Iterator(
				function ()
					map(base.next())
				end
			)

			# Elide mapping unnecessary elements when jumping.
			# This is an important optimization for, e.g.:
			# Array([1,2,3,4,5])
			# 	.map(fun)
			# 	.skip(3)
			# 	.collect()
			it.nth = function (n)
				map(base.nth(n))
			end

			it
		end,

		# Filter the iterator by the given predicate.
		# This function is lazy.
		# Items for which the predicate returns true are kept.
		# Parameters:
		# * pred: function(any) -&gt; bool # the predicate
		# Returns a new iterator, consuming self.
		filter: function (pred)
			let base = self

			Iterator(
				function ()
					let iteration = base.next()

					while not (iteration.finished or pred(iteration.value)) do
						iteration = base.next()
					end

					iteration
				end
			)
		end,

		# Skip elements from the iterator.
		# Equivalent to calling `nth(size - 1)` on an iterator.
		# Returns a new iterator, consuming self.
		skip: function(size)
			if size &gt; 0 then
				self.nth(size - 1)
			end
			self
		end,

		# Iterate up to some elements.
		# This function is lazy.
		# The iterator that will stop after `size` elements.
		# Parameters:
		# * size: int # how many elements to keep
		# Returns a new iterator, consuming self.
		take: function (size)
			let base = self

			let it = Iterator(
				function ()
					if size == 0 then
						@[ finished: true ]
					else
						size = size - 1
						base.next()
					end
				end
			)

			it.nth = function(n)
				if n + 1 &gt; size then
					size = 0
					@[ finished: true ]
				else
					size = size - n
					base.nth(n)
				end
			end

			it
		end,

		# Fold elements into a single value.
		# Parameters:
		# * merge: function(any, any) -&gt; any # the function to merge elements
		# * acc: any # the default argument for merge
		# Returns the resulting any, consuming self.
		fold: function (merge, acc)
			for item in self.iter() do
				acc = merge(item, acc)
			end

			acc
		end,

		# Collect the iterator's items.
		# Parameters:
		# * target: nil, array or function(any) # where to collect
		# If target is nil, the elements are collected into a new array.
		# If target is an array, the elements are collected by pushing to it.
		# If target is a function, the elements are collected by calling the function.
		# Returns nil if target is a function, or the resulting array otherwise.
		collect: function (target)
			let result = []
			let push

			let type = std.type(target)
			if type == &quot;function&quot; then
				result = nil
				push = target
			else
				if type == &quot;array&quot; then
					result = target
				end
				push = function (item)
					std.push(result, item)
				end
			end

			for item in self.iter() do
				push(item)
			end

			result
		end
	]
end

# Construct an iterator for the given array.
# Returns the Iterator instance.
function Array(array)
	let ix = 0

	# Don't use `std.iter` in order to be able to optimize `nth`.
	let it = Iterator(
		function ()
			if ix &gt;= std.len(array) then
				@[ finished: true ]
			else
				let value = array[ix]
				ix = ix + 1
				@[ finished: false, value: value ]
			end
		end
	)

	# Override nth with a O(1) implementation:
	it.nth = function (n)
		ix = ix + n
		return it.next()
	end

	return it
end

# Construct an iterator for the given table.
# There is no guarantee of iteration order.
# Returns the Iterator instance.
function Dict(dict)
	return Iterator(std.iter(dict))
end

# Construct an empty iterator.
# Returns the Iterator instance.
function Empty()
	return Iterator(
		function ()
			return @[ finished: true ]
		end
	)
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wrapping-up-1"><a class="header" href="#wrapping-up-1">Wrapping up</a></h1>
<p>This was an all around quick tutorial on <em>Hush</em>, a modern shell programming language. We hope that it has enabled you to write and maintain robust shell scripts, and that the language proves itself to be a solid tool for system and infrastructure programming. If you have any criticism, suggestions, or want to contribute to the project, feel free to reach us out on <a href="https://github.com/hush-shell/hush">Github</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
                <script type="text/javascript" src="theme/hush-highlight.js"></script>
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
